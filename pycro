#!/usr/bin/python3

import sys
import os
import io
import re
import collections
import marshal

if __debug__:
    def rprint(*objects, sep=', ', end='\n', file=sys.stdout):
        if objects:
            file.write(repr(objects[0]))
            for obj in objects[1:]:
                file.write(sep)
                file.write(repr(obj))
        file.write(end)

_CACHE_FOLDER_NAME = '.pycro_cache'

if sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    _HOME_DIRECTORY = os.environ['HOME']

elif sys.platform == 'win32':
    _HOME_DIRECTORY = os.environ['USERPROFILE']

else:
    raise NotImplemented(
            'implement _HOME_DIRECTORY for your platform: {}'.format(
                sys.platform))


# NOTE: '(?=(...))\1' works like atomic groups in other languages,
#       e.g: in perl: '(?>...)'.

# TODO: using re for matching for macros, statement, ... is slow, may be we
#       can do something like this:
#
#   line = line.strip(_SPACE_CHARS)
#   if line.startswith(prefix) and line.endswith(suffix):
#       ...
#
# WARNING: if we use the above mechanism, evey line that startswith(prefix) and
#          endswith(suffix) will treated as macros, statement, ...
#
# TODO: test speed of both ways.


_MACRO_PATTERN = r'\s*(?P<macro>{macros})\s*(?P<args>.*?)\s*'

# we comment statement pattern because
# _STATEMENT_PATTERN = r'(?P<stat>.*)'

_VARIABLE_NAME_PATTERN = r'[a-zA-Z_][a-zA-Z_0-9]+'

_VARIABLE_PATTERN = r'{prefix}(?P<name>{pattern}){suffix}'

_EVALUATION_PATTERN = r'{prefix}\s*(?P<eval>.*?)\s*{suffix}'


_DEFAULT_OUTFILE_VARIABLE_NAME = '__outfile__'

_SPACE_CHARS = ' \t\n'


_CACHE_FILE_MAGIC_NUMBER = b'.pycroche'

_COMPILE_FLAGS = 0

_MARSHAL_VERSION = 4

__USAGE = "usage: {} [OPTION]... [[--] FILE | -]..."
__HELP = """\
preprocess FILEs to standard output. if no FILE or if FILE is '-', standard
input is read.

Operation modes:
    -h, --help                      display this help and exit
    -a, --arrange-performance       perform options and FILEs according to
                                      their orders

Sortable options:
    -D, --define NAME[=VAR]         define NAME variable as having VALUE or
                                      {default_variable_value}
    -U, --undefine NAME             undefine NAME variable
    -S, --set KEY=VALUE             set KEY setting to VALUE
    -l, --load JSONFILE             load JSONFILE and update variables
    -I, --import MODULE             import MODULE to interpreter variables
    --                              read next argument as input FILE (don't
                                      treats '-' as standard input)
"""
__TRY = "try '{} --help' for more information."

# --- utilities ---

class dotdict(dict):
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

if sys.version_info >= (3, 4):
    __fullmatch = re._pattern_type.fullmatch

else:
    def __fullmatch(pattern, string):
        m = pattern.match(string)
        if m and m.end() == len(string):
            return m

# --- argument parser ---

def __print_help():
    print(__HELP.format(
        default_variable_value = _DEFAULT_VARIABLE_VALUE))

def __parse_argv(argv):
    result = dotdict(
            jobs = collections.deque(),
            operation_modes = set(),

            # NOTE: these fields will be filled on end
            inputs = None,
            settings = None,
            )

    next_args = collections.deque()

    for i, arg in enumerate(argv[1:]):

        # read next arg
        if next_args:
            next_arg = next_args.popleft()
            if next_arg[0] in ('define', 'undefine', 'input', 'setting',
                               'import'):
                result.jobs.append((next_arg[0], arg))

            else:
                raise BaseException("unknown argument name pushed to "
                        "next_args: {}".format(next_arg))

            continue

        # empty argument, ('')
        if not arg:
            print("error: empty argument: #{} argument".format(i + 1))
            print(__TRY.format(argv[0]))
            return 1

        if arg[0] == '-':

            # append stdin as input, ('-')
            if len(arg) == 1:
                continue

            if arg[1] == '-':

                # read next argument as input file name, ('--')
                if len(arg) == 2:
                    next_args.append(('input', '--'))
                    continue

                option = arg[2:]

                # show help, ('--help')
                if option == 'help':
                    print(__USAGE.format(argv[0]))
                    __print_help()
                    return 0

                # order performances, ('--order-performance')
                elif option == 'order-performance':
                    result.operation_modes.add('order')

                # define variable, ('--define')
                elif option == 'define':
                    next_args.append(('define', '--define'))

                # undefine variable, ('--undefine')
                elif option == 'undefine':
                    next_args.append(('undefine', '--undefine'))

                # change settings, ('--set')
                elif option == 'set':
                    next_args.append(('setting', '--set'))

                # load json files, ('--load')
                elif option == 'load':
                    next_args.append(('jsonfile', '--load'))

                # import module, ('--import')
                elif option == 'import':
                    next_args.append(('import', '--import'))

                else:
                    print("error: unknown option: '{}'".format(arg))
                    print(__TRY.format(argv[0]))
                    return 1

            else: # if arg[1] == '-'
                for ch in arg[1:]:

                    # show help, ('-h')
                    if ch == 'h':
                        print(__USAGE.format(sys.argv[0]))
                        __print_help()
                        return 0

                    # order performances, ('-o')
                    elif ch == 'o':
                        result.operation_modes.add('order')

                    # define variable, ('-D')
                    elif ch == 'D':
                        next_args.append(('define', '-D'))

                    # undefine variable, ('-U')
                    elif ch == 'U':
                        next_args.append(('undefine', '-U'))

                    # change settings, ('-S')
                    elif ch == 'S':
                        next_args.append(('setting', '-S'))

                    # load json files, ('-l')
                    elif ch == 'l':
                        next_args.append(('jsonfile', '-l'))

                    # import module, ('-i')
                    elif ch == 'i':
                        next_args.append(('import', '-I'))

                    else:
                        print("error: invalid option: '{}'".format('-' + ch))
                        print(__TRY.format(argv[0]))
                        return 1

        else: # if arg[0] == '-'
            result.jobs.append(('input', arg))

    if next_args:
        print("error: '{}' option requires an argument".format(
            next_args[0][1]
            ))
        print(__TRY.format(argv[0]))
        return 1

    result.inputs = \
            list(tup[1] for tup in result.jobs if tup[0] == 'input')

    result.settings = \
            list(tup[1] for tup in result.jobs if tup[0] == 'setting')

    result.jobs = list(result.jobs)
    return result

# --- binary file operations ---

def __write_code_object(outfile, code_object):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_code_object(infile):
    return marshal.load(infile)

def __write_string(outfile, string):
    _buffer = string.encode('utf-8')

    while len(_buffer) >= 0xFFFF:

        outfile.write(b'\xFF\xFF')
        outfile.write(_buffer[:0xFFFF])
        _buffer = _buffer[0xFFFF:]

    outfile.write(len(_buffer).to_bytes(2, 'big', signed=False))
    outfile.write(_buffer)

def __read_string(infile):
    _buffer_size = int.from_bytes(infile.read(2), 'big', signed=False)
    _buffer = bytearray(infile.read(_buffer_size))

    while _buffer_size == 0xFFFF:
        _buffer_size = int.from_bytes(infile.read(2), 'big', signed=False)
        _buffer += infile.read(_buffer_size)

    return _buffer.decode('utf-8')

# --- errors ---

_MACRO_REQUIRES = 1
_WITHOUT_PRECEDING = 2
_END_DOES_NOT_MATCH = 3
_UNTERMINATED_BLOCK = 4

class CompilerError(Exception):
    pass

# **** macros ****

# --- if macro ---

def _generate_if(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'if', 'a condition')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'if', args))
    env.indent += 1

    env.macro_stack.append('if')

# --- elif macro ---

def _generate_elif(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'elif', 'a condition')

    if env.macro_stack and env.macro_stack[-1] in ('if', 'elif'):

        env.indent -= 1
        outfile.write('{}{} {}:\n'.format(env.tabs(), 'elif', args))
        env.indent += 1

        env.macro_stack[-1] = 'elif'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'elif', 'if/elif')

# --- for macro ---

def _generate_for(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'an iterable statement')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'for', args))
    env.indent += 1

    env.macro_stack.append('for')

# --- while macro ---

def _generate_while(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'while', 'a condition')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'while', args))
    env.indent += 1

    env.macro_stack.append('while')

# --- else macro ---

def _generate_else(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in \
            ('if', 'elif', 'for', 'while', 'except'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'else'))
        env.indent += 1

        env.macro_stack[-1] = 'else'

    else:
        raise CompilerError(_WITHOUT_PRECEDING,
                'else', 'if/elif/for/while/except')

# --- with macro ---

def _generate_with(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'with', 'an expression')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'with', args))
    env.indent += 1

    env.macro_stack.append('with')

# --- try macro ---

def _generator_try(args, outfile, env):
    outfile.write('{}{}:\n'.format(env.tabs, 'try'))
    env.indent += 1

    env.macro_stack.append('try')

# -- except macro ---

def _generator_except(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'except', 'an expression')

    if env.macro_stack and env.macro_stack[-1] in ('try', 'except'):

        env.indent -= 1
        outfile.write('{}{} {}:\n'.format(env.tabs(), 'except', args))
        env.indent += 1

        env.macro_stack[-1] = 'except'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'except', 'try/except')

# --- finally macro ---

def _generate_finally(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in ('try', 'except', 'else'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'finally'))
        env.indent += 1

        env.macro_stack[-1] = 'finally'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'finally', 'try/except/else')


# --- end macro ---

def _generate_include(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    # TODO: implement _generator_include

def _generate_place(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    # TODO: complete _generator_place()


def _generate_end(args, outfile, env):
    if not env.macro_stack:
        raise CompilerError(_WITHOUT_PRECEDING, 'end', 'if/for/while/...')

    last_macro = env.macro_stack.pop()

    if args:
        if args != last_macro:
            raise CompilerError(_END_DOES_NOT_MATCH, 'end', last_macro, args)

    env.indent -= 1


_default_code_generators = {
        'if': _generate_if,
        'elif': _generate_elif,
        'else': _generate_else,
        'for': _generate_for,
        'while': _generate_while,
        'with': _generate_with,
        'end': _generate_end,
}

def _generate_line(line, outfile, env):
    outfile.write(env.tabs())

    m = env.evaluation_re.search(line)
    while m:

        # --- write primitive remains ---
        if m.start() != 0:
            outfile.write(
                '{}.write({});'.format(
                    env.outfile_variable_name,
                    repr(line[:m.start()]),
                )
            )

        # --- write evaluation ---
        outfile.write(
             '{}.write(str({}));'.format(
                 env.outfile_variable_name,
                 m.group('eval'),
             )
        )

        # --- check remaining line ---
        if m.end() == len(line):
            outfile.write('\n')
            break

        line = line[m.end():]
        m = env.evaluation_re.search(line)

    else:

        # --- writing text ---
        outfile.write(
            '{}.write({});\n'.format(
                env.outfile_variable_name,
                repr(line),
            )
        )

class CompilerEnvironment:
    def __init__(
            self,

            code_generators = None,

            macro_prefix = '%',
            macro_suffix = '',

            statement_prefix = '@',
            statement_suffix = '',

            comment_prefix = '#',
            comment_suffix = '',

            variable_prefix = '${',
            variable_suffix = '}',

            evaluation_prefix = '${{',
            evaluation_suffix = '}}',

            line_continuation = '/-',
            next_line_prefix = '/>',

            tab = '\t',
            indent = 0,

            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,
            ):
        """intialize code generator environment"""

        self.code_generators = \
            code_generators or _default_code_generators.copy()

        self.macro_stack = collections.deque()


        # --- macro ---
        self.macro_prefix = macro_prefix
        self.macro_suffix = macro_suffix

        self.macro_re = re.compile(
            _MACRO_PATTERN.format(
                macros = '|'.join(macro for macro in self.code_generators),
            )
        )

        # --- statement ---
        self.statement_prefix = statement_prefix
        self.statement_suffix = statement_suffix

        # --- comment ---
        self.comment_prefix = comment_prefix
        self.comment_suffix = comment_suffix


        # --- evaluation & variable ---
        if (not variable_prefix) or (not variable_suffix):
            raise ValueError(
                    "variable_prefix & variable_suffix can't be empty")

        if (not evaluation_prefix) or (not evaluation_suffix):
            raise ValueError(
                    "evaluation_prefix & evaluation_suffix can't be empty")

        self.evaluation_variable_re = re.compile(
            _EVALUATION_PATTERN.format(
                prefix = re.escape(evaluation_prefix),
                suffix = re.escape(evaluation_suffix),
            ) + '|' +

            _VARIABLE_PATTERN.format(
                prefix = re.escape(variable_prefix),
                pattern = _VARIABLE_NAME_PATTERN,
                suffix = re.escape(variable_suffix),
            )
        )


        # --- line continuation & next line ---
        self.line_continuation = line_continuation
        self.next_line_prefix = next_line_prefix

        # --- outfile variable name ---
        self.outfile_variable_name = outfile_variable_name


        self.indent = indent
        self.tab = tab

    def tabs(self):
        return self.tab * self.indent

def generate_code(infile, outfile, env):
    """read from infile and generats python code to outfile"""

    code_generators = env.code_generators

    # --- macro ---
    macro_prefix = env.macro_prefix
    macro_suffix = env.macro_suffix

    macro_re = env.macro_re

    # --- statement ---
    statement_prefix = env.statement_prefix
    statement_suffix = env.statement_suffix

    # --- comment ---
    comment_prefix = env.comment_prefix
    comment_suffix = env.comment_suffix

    # --- evaluation variable ---
    evaluation_variable_re = env.evaluation_variable_re

    # --- line continuation & next line ---
    line_continuation = env.line_continuation
    next_line_prefix = env.next_line_prefix

    # --- outfile variable name ---
    outfile_variable_name = env.outfile_variable_name

    for line in infile:

        # append next line while line.endswith(line_continuation)
        if line_continuation:

            # NOTE: it's so clear what the fuck i'm doing here.

            r_striped_line = line.rstrip(_SPACE_CHARS)

            while r_striped_line.endswith(line_continuation):
                r_striped_line = r_striped_line[:-len(line_continuation)]

                next_line = infile.readline()
                if not next_line:
                    break

                outfile.write('\n')

                l_striped_next_line = next_line.lstrip(_SPACE_CHARS)

                if l_striped_next_line.startswith(next_line_prefix):
                    line = \
                        r_striped_line \
                        + \
                        l_striped_next_line[len(next_line_prefix):]

                else:
                    line = r_striped_line + next_line

                r_striped_line = line.rstrip(_SPACE_CHARS)

            striped_line = r_striped_line.lstrip(_SPACE_CHARS)

        else:
            striped_line = line.strip(_SPACE_CHARS)

        # now we can check two variables:
        # striped_line & line

        # --- check macro ---
        if striped_line.startswith(macro_prefix) and \
                striped_line.endswith(macro_suffix):

            macro_striped_line = \
                striped_line[   len(macro_prefix): \
                                len(striped_line) - len(macro_suffix)]

            m = __fullmatch(macro_re, macro_striped_line)
            if m:

                generate_code = code_generators[m.group('macro')]
                generate_code(m.group('args'), outfile, env)

                continue

        # --- check statement ---
        if striped_line.startswith(statement_prefix) and \
                striped_line.endswith(statement_suffix):
            outfile.write(
                '{}{}\n'.format(
                    env.tabs(),
                    striped_line[
                            len(statement_prefix): \
                            len(striped_line) -len(statement_suffix)],
                    )
                )

            continue

        # --- check comment ---
        if striped_line.startswith(comment_prefix) and \
                striped_line.endswith(comment_suffix):
            outfile.write('\n')

            continue

        # --- check for evaluations ---
        outfile.write(env.tabs())

        m = evaluation_variable_re.search(line)
        while m:

            # --- write primitive remains ---
            if m.start() != 0:
                outfile.write(
                    '{}.write({});'.format(
                        outfile_variable_name,
                        repr(line[:m.start()]),
                    )
                )

            name = m.group('name')
            if name is None:
                # --- write evaluation ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        m.group('eval'),
                    )
                )

            else:
                # --- write variable ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        name,
                    )
                )

            # --- check remaining line ---
            if m.end() == len(line):
                outfile.write('\n')
                break

            line = line[m.end():]
            m = evaluation_variable_re.search(line)

        else:

            # --- writing text ---
            outfile.write(
                '{}.write({});\n'.format(
                    outfile_variable_name,
                    repr(line),
                )
            )

    if env.macro_stack:
        raise CompilerError(_UNTERMINATED_BLOCK, env.macro_stack[-1])

def compile_code(infile, outfile, env,
        compile_flags = _COMPILE_FLAGS, optimize = -1):
    string_buffer = io.StringIO()
    with string_buffer:
        generate_code(infile, string_buffer, env)

    code_object = compile(string_buffer.getvalue(), infile.name, 'exec',
            flags, True, optimize)

    # --- magic number ---
    outfile.write(_CACHE_FILE_MAGIC_NUMBER)

    # TODO: it must write prefixes & suffixes

    outfile.write()

    __write_code_object(outfile, code_object)

def _compile_if_needed():
    pass

def execute_code(infile, outfile, variables, env):
    if infile.read(len(_CACHE_FILE_MAGIC_NUMBER)) != _CACHE_FILE_MAGIC_NUMBER:
        raise ValueError('file magic number mismatch!')

    code_object = __read_code_object(infile)

    exec(code_object, variables)


# --- main function ---

_default_language_specifications = {
    'c': dotdict(
        macro_prefix =          '//%',
        macro_suffix =          '',

        statement_prefix =      '//@',
        statement_suffix =      '',

        comment_prefix =        '//#',
        comment_suffix =        '',

        variable_prefix =       '${',
        variable_suffix =       '}',

        evaluation_prefix =     '$${{',
        evaluation_suffix =     '}}',

        line_continuation =     '',
        next_line_prefix =      '',
    )
}

__joinpath = os.path.join

if sys.platform == 'win32':
    def __get_cache_file_path(cache_folder_path, file_real_path):
        parts = file_real_path.split(os.sep)
        return __joinpath(cache_folder_path, parts[0][0].lower(), *parts[1:])

else:
    raise NotImplemented(
            'implement __get_cache_file_path() for your platform: {}'.format(
                sys.platform))

def main(argv):
    options = __parse_argv(sys.argv)
    if isinstance(options, int):
        return options

    for file_name in options.inputs:
        pass

if __name__ == '__main__':
    if __debug__:
        string_buffer = io.StringIO()
        env = CompilerEnvironment(**_default_language_specifications['c'])
        with open('temp.c') as infile:
            generate_code(infile, string_buffer, env)

        print(string_buffer.getvalue())
        print('-' * 80)

    else:
        sys.exit(main(sys.argv))
