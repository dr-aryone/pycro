#!/usr/bin/python3

import sys
import os
import io
import re
import collections
import marshal
import subprocess
import configparser
import queue

if sys.version_info[0] == 3:
    import builtins

elif sys.version_info[0] == 2:
    import __builtins__ as builtins

else:
    raise NotImplemented(
            "import builtins module for your python version: {}".format(
                ','.join(n for n in sys.version_info[:3]),
            )
        )

_CACHE_FOLDER_NAME = '.pycro_cache'

_CONFIG_FILE_NAME = '.pycro'

if sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    _HOME_DIRECTORY = os.environ['HOME']

elif sys.platform == 'win32':
    _HOME_DIRECTORY = os.environ['USERPROFILE']

else:
    raise NotImplemented(
            'implement _HOME_DIRECTORY for your platform: {}'.format(
                sys.platform))


# NOTE: '(?=(...))\1' works like atomic groups in other languages,
#       e.g: in perl: '(?>...)'.

# TODO: using re for matching for macros, statement, ... is slow, may be we
#       can do something like this:
#
#   line = line.strip(_SPACE_CHARS)
#   if line.startswith(prefix) and line.endswith(suffix):
#       ...
#
# WARNING: if we use the above mechanism, evey line that startswith(prefix) and
#          endswith(suffix) will treated as macros, statement, ...
#
# TODO: test speed of both ways.


_MACRO_PATTERN = r'\s*(?P<macro>{macros})\s*(?P<args>.*?)\s*'

_VARIABLE_NAME_PATTERN = r'[a-zA-Z_][a-zA-Z_0-9]*'
_VARIABLE_NAME_RE = re.compile(_VARIABLE_NAME_PATTERN)

_VARIABLE_PATTERN = r'{prefix}(?P<name>{pattern}){suffix}'
_EVALUATION_PATTERN = r'{prefix}\s*(?P<eval>.*?)\s*{suffix}'



_DEFAULT_VARIABLE_VALUE = None
_SPACE_CHARS = ' \t\n'


# NOTE: pycro reversed variable names

_DEFAULT_OUTFILE_VARIABLE_NAME = '__outfile__'

_DEFAULT_PIPES_VARIABLE_NAME = '__pipes__'
_DEFAULT_DIVERT_FUNCTION_NAME = '__divert__'
_DEFAULT_UNDIVERT_FUNCTION_NAME = '__undivert__'

_DEFAULT_RUN_FUNCTION_NAME = '__run__'

_DEFAULT_INCLUDE_FUNCTION_NAME = '__include__'
_DEFAULT_PLACE_FUNCTION_NAME = '__place__'



_CACHE_FILE_MAGIC_NUMBER = b'.pycroche'

_COMPILE_FLAGS = 0
_OPTIMIZE_FLAG = -1
_MARSHAL_VERSION = 4

_BIG_INTEGER_SIZE = 4


# TODO: some interesting options:
#       -

__USAGE = "usage: {} [OPTION]... [[--] FILE | -]..."
__HELP = """\
Pycro FILEs to standard output. if no FILE or if FILE is '-', standard input is
read.

Operation modes:
    -h, --help                      display this help and exit
    -a, --arrange-process           perform OPTIONs and FILEs according to
                                      their orders
    --list-settings                 list setting keys and exit
    --list-languages                list predefined programming languages and
                                      exit

Sortable options:
    -D, --define NAME[=VAR]         define NAME variable as having VALUE, or
                                      {default_variable_value}
    -U, --undefine NAME             undefine NAME variable
    -S, --set KEY=VALUE             set KEY setting to VALUE
    -L, --lang LANGUAGE             set prefix and suffix for LANGUAGE
                                      specification
    -l, --load JSONFILE             load JSONFILE and update variables
    -I, --import MODULE             import MODULE to interpreter variables
    -- FILE                         read next argument as input FILE (don't
                                      treats '-' as standard input)

Common options:
    -C, --clear-cache               first clear compiler cache
""".format(
    default_variable_value = _DEFAULT_VARIABLE_VALUE
)
__TRY = "try '{} --help' for more information."

__setting_keys = {
    'mp', 'macro_prefix'                'ms', 'macro_suffix',
    'sp', 'statement_prefix',           'ss', 'statement_suffix',
    'cp', 'comment_prefix',             'cs', 'comment_suffix',
    'vp', 'variable_prefix',            'vs', 'variable_suffix',
    'ep', 'evaluation_prefix',          'es', 'evaluation_suffix',
}

# --- debuging code ---

if __debug__:
    from pprint import pprint

    def print_line(title = None, fill='-', width=80):
        if title:
            print('{:{fill}^{width}}'.format(
                    ' ' + title.strip() + ' ',
                    width=80,
                    fill=fill,
                    )
                )
        else:
            print(fill * width)

    def rprint(*objects, sep=', ', end='\n', file=sys.stdout):
        if objects:
            file.write(repr(objects[0]))
            for obj in objects[1:]:
                file.write(sep)
                file.write(repr(obj))
        file.write(end)

# --- utilities ---

__joinpath = os.path.join
__abspath = os.path.abspath
__realpath = os.path.realpath

if sys.version_info >= (3, 4):
    __fullmatch = re._pattern_type.fullmatch

else:
    def __fullmatch(pattern, string):
        m = pattern.match(string)
        if m and m.end() == len(string):
            return m

if sys.version_info[0] == 3:
    __fdopen = open

elif sys.version_info[0] == 2:
    __fdopen = os.fdopen

else:
    raise NotImplemented(
            "implement __fdopen function for your python version: {}".format(
                ','.join(n for n in sys.version_info[:3]),
            )
        )

def _create_pipe(read_mode = 'rt', write_mode = 'wt'):
    read_fd, write_fd = os.pipe()
    return __fdopen(read_fd, read_mode), __fdopen(write_fd, write_mode)

class dotdict(dict):
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__


class FileStructError(Exception):
    pass

# we have no code object type definition
_code_object_type = type(compile('0', '', 'eval'))

# --- argument parser ---

def __print_help():
    print(__HELP)

def __print_erro(line):
    print('pycro: error:', line)

def __parse_argv(argv):
    result = dotdict(
            jobs = collections.deque(),
            switchs = set(),

            # NOTE: these fields will be filled on end
            inputs = None,
            settings_langs = None,
            )

    next_args = collections.deque()

    input_number = 0

    for i, arg in enumerate(argv[1:]):

        # read next arg
        if next_args:
            next_arg = next_args.popleft()
            if next_arg[0] in ('input', 'import', 'lang', 'jsonfile'):
                result.jobs.append((next_arg[0], arg))

            elif next_arg[0] == 'input':
                result.jobs.append(('input', arg))
                input_number += 1

            elif next_arg[0] == 'define':

                # --- parsing definition ---
                arg = arg.split('=', maxsplit=1)
                if len(arg) != 2:
                    __print_erro(
                        "{!r} option requires a 'NAME=VALUE' pair.".format(
                            next_arg[1],
                        )
                    )
                    print(__TRY.format(argv[0]))
                    return 1

                if not __fullmatch(_VARIABLE_NAME_RE, arg[0]):
                    __print_erro(
                        "invalid variable name: {!r} for option: {!r}".format(
                            arg[0],
                            next_arg[1],
                        )
                    )
                    print(__TRY.format(argv[0]))
                    return 1

                result.jobs.append(('define', arg))

            elif next_arg[0] == 'undefine':

                # --- parsing undefinition ---
                if not __fullmatch(_VARIABLE_NAME_RE, arg):
                    __print_erro(
                        "invalid variable name: {!r} for option: {!r}".format(
                            arg,
                            next_arg[1],
                        )
                    )
                    print(__TRY.format(argv[0]))
                    return 1

                result.jobs.append(('undefine', arg))

            elif next_arg[0] == 'setting':

                # --- parsing setting ---
                arg = arg.split('=', maxsplit=1)
                if len(arg) != 2:
                    __print_erro(
                        "{!r} option requires a 'KEY=VALUE' pair.".format(
                            next_arg[1],
                        )
                    )
                    print(__TRY.format(argv[0]))
                    return 1

                if arg[0] not in __setting_keys:
                    __print_erro(
                        "invalid setting key: {!r} for option: {!r}".format(
                            arg[0],
                            next_arg[1],
                        )
                    )
                    print(__TRY.format(argv[0]))
                    return 1

                result.jobs.append(('setting', arg))

            else:
                raise BaseException("unknown argument name pushed to "
                        "next_args: {}".format(next_arg))

            continue

        # empty argument
        if not arg:
            __print_erro("empty argument: #{} argument".format(i + 1))
            print(__TRY.format(argv[0]))
            return 1

        if arg[0] == '-':

            # append stdin as input
            if len(arg) == 1:
                result.jobs.append(('input', sys.stdin))
                input_number += 1
                continue

            if arg[1] == '-':

                # read next argument as input file name
                if len(arg) == 2:
                    next_args.append(('input', '--'))
                    continue

                option = arg[2:]

                # show help
                if option == 'help':
                    print(__USAGE.format(argv[0]))
                    __print_help()
                    return 0

                # arrange performances
                elif option == 'arrange-process':
                    result.switchs.add('arrange')

                elif option == 'list-languages':
                    # TODO: list languages
                    return 0

                elif option == 'list-settings':
                    # TODO: list settings
                    return 0

                # clear cache
                elif option == 'clear-cache':
                    result.switchs.add('clear')

                # define variable
                elif option == 'define':
                    next_args.append(('define', '--define'))

                # undefine variable
                elif option == 'undefine':
                    next_args.append(('undefine', '--undefine'))

                # change settings
                elif option == 'set':
                    next_args.append(('setting', '--set'))

                # specify language
                elif option == 'lang':
                    next_args.append(('lang', '--lang'))

                # load json files
                elif option == 'load':
                    next_args.append(('jsonfile', '--load'))

                # import module
                elif option == 'import':
                    next_args.append(('import', '--import'))

                else:
                    __print_erro("unknown option: '{}'".format(arg))
                    print(__TRY.format(argv[0]))
                    return 1

            else: # if arg[1] == '-'
                for ch in arg[1:]:

                    # show help
                    if ch == 'h':
                        print(__USAGE.format(sys.argv[0]))
                        __print_help()
                        return 0

                    # arrange performances
                    elif ch == 'a':
                        result.switchs.add('arrange')

                    # clear cache
                    elif ch == 'C':
                        result.switchs.add('clear')

                    # define variable
                    elif ch == 'D':
                        next_args.append(('define', '-D'))

                    # undefine variable
                    elif ch == 'U':
                        next_args.append(('undefine', '-U'))

                    # change settings
                    elif ch == 'S':
                        next_args.append(('setting', '-S'))

                    # specify language
                    elif ch == 'L':
                        next_args.append(('lang', '-L'))

                    # load json files
                    elif ch == 'l':
                        next_args.append(('jsonfile', '-l'))

                    # import module
                    elif ch == 'i':
                        next_args.append(('import', '-I'))

                    else:
                        __print_erro("invalid option: '{}'".format('-' + ch))
                        print(__TRY.format(argv[0]))
                        return 1

        else: # if arg[0] == '-'
            result.jobs.append(('input', arg))
            input_number += 1

    if next_args:
        __print_erro(
                "'{}' option requires an argument".format(next_args[0][1]))
        print(__TRY.format(argv[0]))
        return 1

    if input_number == 0:
        result.jobs.append(('input', sys.stdin))

    result.inputs = \
            list(tup[1] for tup in result.jobs if tup[0] == 'input')

    result.settings_langs = \
            list(
                tup[1] for tup in result.jobs if tup[0] in ('setting', 'lang')
            )


    result.jobs = list(result.jobs)
    return result

# *** binary file operations ***

# --- objects ---

def __write_object(outfile, _set):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_object(infile):
    return marshal.load(infile)

# --- code objects ---

def __write_code_object(outfile, code_object):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_code_object(infile):
    result = marshal.load(infile)
    if not isinstance(result, _code_object_type):
        raise FileStructError('invalid object type while reading code object')
    return marshal.load(infile)

# --- integers ---

def __write_int(outfile, integer, size = 1):
    outfile.write(integer.to_bytes(size, 'big', signed = True))

def __write_uint(outfile, integer, size = 1):
    outfile.write(integer.to_bytes(size, 'big', signed = False))

def __read_int(infile, size = 1):
    _buffer = infile.read(size)
    if len(_buffer) != size:
        raise EOFError(
                "End of file while reading {} byte integer".format(size))
    return int.from_bytes(_buffer, 'big', signed = True)

def __read_uint(infile, size = 1):
    _buffer = infile.read(size)
    if len(_buffer) != size:
        raise EOFError(
                "End of file while reading {} byte integer".format(size))
    return int.from_bytes(_buffer, 'big', signed = False)

# --- big integer ---

def __write_big_integer(outfile, size):
    outfile.write(size.to_bytes(__BIG_INTEGER_SIZE, 'big', signed = False))

def __read_big_integer(infile):
    _buffer = infile.read(__BIG_INTEGER_SIZE)
    if len(_buffer) != __BIG_INTEGER_SIZE:
        raise EOFError("End of file while reading size")
    return int.from_bytes(_buffer, 'big', signed = False)

# --- strings ---

def __write_string(outfile, string):
    _buffer = string.encode('utf-8')

    while len(_buffer) >= 0xFFFF:

        outfile.write(b'\xFF\xFF')
        outfile.write(_buffer[:0xFFFF])
        _buffer = _buffer[0xFFFF:]

    outfile.write(len(_buffer).to_bytes(2, 'big', signed = False))
    outfile.write(_buffer)

def __read_string(infile):
    _buffer = infile.read(2)
    if len(_buffer) != 2:
        raise EOFError("End of file while reading string")
    _buffer_size = int.from_bytes(_buffer, 'big', signed = False)

    _buffer = infile.read(_buffer_size)
    if len(_buffer) != _buffer_size:
        raise EOFError("End of file while reading string")
    _result = bytearray(_buffer)

    while _buffer_size == 0xFFFF:
        _buffer = infile.read(2)
        if len(_buffer) != 2:
            raise EOFError("End of file while reading string")
        _buffer_size = int.from_bytes(_buffer, 'big', signed = False)

        _buffer = infile.read(_buffer_size)
        if len(_buffer) != _buffer_size:
            raise EOFError("End of file while reading string")

        _result += _buffer

    return _result.decode('utf-8')

# *** errors ***

# NOTE: cross-python-version error values
_MACRO_REQUIRES = 1
_WITHOUT_PRECEDING = 2
_END_DOES_NOT_MATCH = 3
_UNTERMINATED_BLOCK = 4

class CompilerError(Exception):
    pass

# *** macros ***

# --- if macro ---

def _generate_if(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'if', 'a condition')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'if', args))
    env.indent += 1

    env.macro_stack.append('if')

# --- elif macro ---

def _generate_elif(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'elif', 'a condition')

    if env.macro_stack and env.macro_stack[-1] in ('if', 'elif'):

        env.indent -= 1
        outfile.write('{}{} {}\n'.format(env.tabs(), 'elif', args))
        env.indent += 1

        env.macro_stack[-1] = 'elif'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'elif', 'if/elif')

# --- for macro ---

def _generate_for(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'an iterable statement')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'for', args))
    env.indent += 1

    env.macro_stack.append('for')

# --- while macro ---

def _generate_while(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'while', 'a condition')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'while', args))
    env.indent += 1

    env.macro_stack.append('while')

# --- try macro ---

def _generate_try(args, outfile, env):
    outfile.write('{}{}:\n'.format(env.tabs, 'try'))
    env.indent += 1

    env.macro_stack.append('try')

# -- except macro ---

def _generate_except(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'except', 'an expression')

    if env.macro_stack and env.macro_stack[-1] in ('try', 'except'):

        env.indent -= 1
        outfile.write('{}{} {}\n'.format(env.tabs(), 'except', args))
        env.indent += 1

        env.macro_stack[-1] = 'except'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'except', 'try/except')

# --- finally macro ---

def _generate_finally(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in ('try', 'except', 'else'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'finally'))
        env.indent += 1

        env.macro_stack[-1] = 'finally'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'finally', 'try/except/else')

# --- else macro ---

def _generate_else(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in \
            ('if', 'elif', 'for', 'while', 'except'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'else'))
        env.indent += 1

        env.macro_stack[-1] = 'else'

    else:
        raise CompilerError(_WITHOUT_PRECEDING,
                'else', 'if/elif/for/while/except')

# --- with macro ---

def _generate_with(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'with', 'an expression')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'with', args))
    env.indent += 1

    env.macro_stack.append('with')

# --- def macro ---

def _generate_def(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'def', 'a function definition')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'def', args))
    env.indent += 1

    env.macro_stack.append('def')

# --- end macro ---

def _generate_end(args, outfile, env):
    if not env.macro_stack:
        raise CompilerError(_WITHOUT_PRECEDING, 'end', 'if/for/while/...')

    last_macro = env.macro_stack.pop()

    if args:
        if args != last_macro:
            raise CompilerError(_END_DOES_NOT_MATCH, 'end', last_macro, args)

    env.indent -= 1

# --- divert macro ---

def _generate_divert(args, outfile, env):
    outfile.write(
        '{}{}({})\n'.format(
            env.tabs(),
            env.divert_function_name,
            args
        )
    )

# -- undivert macro ---

def _generate_undivert(args, outfile, env):
    outfile.write(
        '{}{}({})\n'.format(
            env.tabs(),
            env.undivert_function_name,
            args
        )
    )

# --- place macro ---

def _generate_place(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'place', 'a filename')

    outfile.write(
        '{}{}({})\n'.format(
            env.tabs(),
            env.place_function_name,
            args,
        )
    )

# --- include macro ---

# TODO: complete _generator_include()

def _generate_include(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    outfile.write(
        '{}{}({})\n'.format(
            env.tabs(),
            env.include_function_name,
            args,
        )
    )


# --- run macro ---

def _generate_run(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'run', 'a command')

    outfile.write(
        '{}{}({})\n'.format(
            env.tabs(),
            env.run_function_name,
            args,
        )
    )

# --- load macro ---

# TODO: write _generate_load()

def _generate_load(args, outfile, env):
    pass

_default_code_generators = {
        'if': _generate_if,
        'elif': _generate_elif,

        'for': _generate_for,
        'while': _generate_while,

        'try': _generate_try,
        'except': _generate_except,
        'finally': _generate_finally,

        'else': _generate_else,
        'with': _generate_with,

        'def': _generate_def,
        'end': _generate_end,

        'divert': _generate_divert,
        'undivert': _generate_undivert,

        'place': _generate_place,
        # TODO: add 'include' when ready

        'run': _generate_run,

        # TODO: add 'load' when ready
}

class CompilerEnvironment:
    def __init__(
            self,

            code_generators = None,

            macro_prefix = '@',
            macro_suffix = '',

            statement_prefix = '#',
            statement_suffix = '',

            comment_prefix = '%',
            comment_suffix = '',

            variable_prefix = '${',
            variable_suffix = '}',

            evaluation_prefix = '$${{',
            evaluation_suffix = '}}',

            tab = '\t',
            indent = 0,

            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,

            pipes_varaible_name = _DEFAULT_PIPES_VARIABLE_NAME,
            divert_function_name = _DEFAULT_DIVERT_FUNCTION_NAME,
            undivert_function_name = _DEFAULT_UNDIVERT_FUNCTION_NAME,

            run_function_name = _DEFAULT_RUN_FUNCTION_NAME,

            include_function_name = _DEFAULT_INCLUDE_FUNCTION_NAME,
            place_function_name = _DEFAULT_PLACE_FUNCTION_NAME,
            ):
        """intialize code generator environment"""

        self.code_generators = \
            code_generators or _default_code_generators.copy()

        self.macro_stack = collections.deque()


        # --- macro ---
        self.macro_prefix = macro_prefix
        self.macro_suffix = macro_suffix

        self.macro_re = re.compile(
            _MACRO_PATTERN.format(
                macros = '|'.join(macro for macro in self.code_generators),
            )
        )

        # --- statement ---
        self.statement_prefix = statement_prefix
        self.statement_suffix = statement_suffix

        # --- comment ---
        self.comment_prefix = comment_prefix
        self.comment_suffix = comment_suffix


        # --- evaluation & variable ---
        if (not variable_prefix) or (not variable_suffix):
            raise ValueError(
                    "variable_prefix & variable_suffix can't be empty")

        if (not evaluation_prefix) or (not evaluation_suffix):
            raise ValueError(
                    "evaluation_prefix & evaluation_suffix can't be empty")

        self.evaluation_variable_re = re.compile(
            _EVALUATION_PATTERN.format(
                prefix = re.escape(evaluation_prefix),
                suffix = re.escape(evaluation_suffix),
            ) + '|' +

            _VARIABLE_PATTERN.format(
                prefix = re.escape(variable_prefix),
                pattern = _VARIABLE_NAME_PATTERN,
                suffix = re.escape(variable_suffix),
            )
        )

        # --- variable names ---
        self.outfile_variable_name = outfile_variable_name

        self.pipes_varaible_name = pipes_varaible_name
        self.divert_function_name = divert_function_name
        self.undivert_function_name = undivert_function_name

        self.run_function_name = run_function_name

        self.include_function_name = include_function_name
        self.place_function_name = place_function_name

        # --- indent & tabs ---

        self.indent = indent
        self.tab = tab

    def tabs(self):
        return self.tab * self.indent

def generate_code(infile, outfile, env):
    """read from infile and generats python code to outfile"""

    code_generators = env.code_generators

    # --- macro ---
    macro_prefix = env.macro_prefix
    macro_suffix = env.macro_suffix

    macro_re = env.macro_re

    # --- statement ---
    statement_prefix = env.statement_prefix
    statement_suffix = env.statement_suffix

    # --- comment ---
    comment_prefix = env.comment_prefix
    comment_suffix = env.comment_suffix

    # --- evaluation variable ---
    evaluation_variable_re = env.evaluation_variable_re

    # --- outfile variable name ---
    outfile_variable_name = env.outfile_variable_name

    for line in infile:

        striped_line = line.strip(_SPACE_CHARS)

        # --- check macro ---
        if striped_line.startswith(macro_prefix) and \
                striped_line.endswith(macro_suffix):

            macro_striped_line = \
                striped_line[   len(macro_prefix): \
                                len(striped_line) - len(macro_suffix)]

            m = __fullmatch(macro_re, macro_striped_line)
            if m:

                generate_code = code_generators[m.group('macro')]
                generate_code(m.group('args'), outfile, env)

                continue

        # --- check statement ---
        if striped_line.startswith(statement_prefix) and \
                striped_line.endswith(statement_suffix):
            outfile.write(
                '{}{}\n'.format(
                    env.tabs(),
                    striped_line[
                            len(statement_prefix): \
                            len(striped_line) -len(statement_suffix)] \
                                .strip(_SPACE_CHARS),
                    )
                )

            continue

        # --- check comment ---
        if striped_line.startswith(comment_prefix) and \
                striped_line.endswith(comment_suffix):
            outfile.write('\n')

            continue

        # --- check for evaluations & variables ---
        outfile.write(env.tabs())

        m = evaluation_variable_re.search(line)
        while m:

            # --- write primitive remains ---
            if m.start() != 0:
                outfile.write(
                    '{}.write({});'.format(
                        outfile_variable_name,
                        repr(line[:m.start()]),
                    )
                )

            name = m.group('name')

            if name is None:
                # --- write evaluation ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        m.group('eval'),
                    )
                )

            else:
                # --- write variable ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        name,
                    )
                )

            # --- check remaining line ---
            if m.end() == len(line):
                outfile.write('\n')
                break

            line = line[m.end():]
            m = evaluation_variable_re.search(line)

        else:

            # --- writing text ---
            outfile.write(
                '{}.write({});\n'.format(
                    outfile_variable_name,
                    repr(line),
                )
            )

    if env.macro_stack:
        raise CompilerError(_UNTERMINATED_BLOCK, env.macro_stack[-1])

def compile_generated_code(code, infile_name,
        compile_flags = _COMPILE_FLAGS, optimize = _OPTIMIZE_FLAG):

    return compile(code, infile_name, 'exec', compile_flags, True, optimize)

def compile_file(infile, env,
        compile_flags = _COMPILE_FLAGS, optimize = _OPTIMIZE_FLAG):

    string_buffer = io.StringIO()
    with string_buffer:
        generate_code(infile, string_buffer, env)

    return compile(string_buffer.getvalue(), infile.name, 'exec',
            compile_flags, True, optimize)

_default_builtins = builtins

class ExecutorEnvironment:
    def __init__(self,
            variables = None,
            builtins = None,

            pipes = None,

            # --- variable names ---
            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,

            pipes_varaible_name = _DEFAULT_PIPES_VARIABLE_NAME,
            divert_function_name = _DEFAULT_DIVERT_FUNCTION_NAME,
            undivert_function_name = _DEFAULT_UNDIVERT_FUNCTION_NAME,

            run_function_name = _DEFAULT_RUN_FUNCTION_NAME,

            include_function_name = _DEFAULT_INCLUDE_FUNCTION_NAME,
            place_function_name = _DEFAULT_PLACE_FUNCTION_NAME,
            ):

        if variables is None:
            variables = {}

        if '__builtins__' not in variables:
            if builtins is None:
                builtins = _default_builtins

            variables['__builtins__'] = builtins

        self.variables = variables

        self.pipes = pipes or collections.defaultdict(io.StringIO)

        # --- variable names ---
        self.outfile_variable_name = outfile_variable_name

        self.pipes_varaible_name = pipes_varaible_name
        self.divert_function_name = divert_function_name
        self.undivert_function_name = undivert_function_name

        self.run_function_name = run_function_name

        self.include_function_name = include_function_name
        self.place_function_name = place_function_name

def execute_code_object(
        code_object,
        outfile,
        env,

        working_directory = '.',
        ):

    variables = env.variables

    pipes = env.pipes

    pipes[None] = outfile

    # --- outfile variable ---

    variables[env.outfile_variable_name] = outfile

    # --- pipes variable ---

    variables[env.pipes_varaible_name] = pipes

    # --- divert function ---

    def _divert_function(target = None):
        if not (isinstance(target, (str, int)) or target is None):
            raise TypeError(
                    "divert target must be type of str or int or None")
        variables[env.outfile_variable_name] = pipes[target]

    variables[env.divert_function_name] = _divert_function

    # --- undivert function ---

    def _undivert_function(target):
        if not isinstance(target, (str, int)):
            raise TypeError(
                    "undivert target must be type of str or int")
        outfile.write(pipes[target].getvalue())

    variables[env.undivert_function_name] = _undivert_function

    # --- place function ---

    def _place_function(file_name, output = None):
        output = env.pipes[output]
        with open(__joinpath(working_directory, file_name)) as infile:
            output.write(infile.read())

    variables[env.place_function_name] = _place_function

    # --- include function ---

    # TODO: write _include_function

    # --- run function ---

    def _run_function(command,
            stdin = None,
            stdout = None,
            stderr = None,
            check = True
            ):

        if stdin is None:
            input = ''
        elif isinstance(stdin, (str, int)):
            input = pipes[stdin].getvalue()
        else:
            raise TypeError("run stdin argument must be type of str or int")

        if stdout is None or isinstance(stdout, (str, int)):
            stdout = pipes[stdout]
        else:
            raise TypeError(
                    "run stdout argument must be type of str or int or None")

        if stderr is None or isinstance(stderr, (str, int)):
            stderr = pipes[stderr]
        else:
            raise TypeError(
                    "run stderr argument must be type of str or int or None")

        subprocess.run(command, input=input, stdout=stdout, stderr=stderr)

    variables[env.run_function_name] = _run_function

    # --- load function ---

    # TODO: write load function

    # --- executing code_object ---

    return exec(code_object, variables)


# --- main functions ---

def __write_compiled_code_env(code_object, env, outfile):
    # --- writing to file ---
    outfile.write(_CACHE_FILE_MAGIC_NUMBER)

    __write_string(outfile, env.macro_prefix)
    __write_string(outfile, env.macro_suffix)

    __write_string(outfile, env.statement_prefix)
    __write_string(outfile, env.statement_suffix)

    __write_string(outfile, env.comment_prefix)
    __write_string(outfile, env.comment_suffix)

    __write_string(outfile, env.variable_prefix)
    __write_string(outfile, env.variable_suffix)

    __write_string(outfile, env.evaluation_prefix)
    __write_string(outfile, env.evaluation_suffix)

    __write_code_object(outfile, code_object)

def __read_compiled_code(infile, env):
    if infile.read(len(_CACHE_FILE_MAGIC_NUMBER)) != _CACHE_FILE_MAGIC_NUMBER:
        raise FileStructError('file magic number mismatch')

    if \
            env.macro_prefix == __read_string(infile) and \
            env.macro_suffix == __read_string(infile) and \
            env.statement_prefix == __read_string(infile) and \
            env.statement_suffix == __read_string(infile) and \
            env.comment_prefix == __read_string(infile) and \
            env.comment_suffix == __read_string(infile) and \
            env.variable_prefix == __read_string(infile) and \
            env.variable_suffix == __read_string(infile) and \
            env.evaluation_prefix == __read_string(infile) and \
            env.evaluation_suffix == __read_string(infile):

        return __read_code_object(infile)

    return None

def __compile_if_needed(code_path, cache_path, compiler_env):
    code_stat = os.stat(code_path)
    try:
        # may raise FileNotFoundError
        cache_stat = os.stat(cache_path)

        if code_stat.st_mtime_ns < cache_stat.st_mtime_ns:

            # this also may raise FileNotFoundError
            with open(cache_path, 'rb') as cache_file:

                # may raise FileStructError or EOFError
                code_object = __read_compiled_code(cache_file, compiler_env)

                # __read_compiled_code() return None if prefixes & suffixes
                # mismatch

                if code_object is not None:
                    return code_object

    except (FileNotFoundError, EOFError, FileStructError):
        pass

    # compile the file
    with open(code_path, 'rt') as code_file:
        code_object = compile_file(code_file, compiler_env)

    # cache the compiled code_object
    with open(cache_path, 'wb') as cache_file:
        __write_compiled_code_env(code_object, compiler_env, cache_file)

    # return the result
    return code_object

if sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    def __get_cache_file_path(cache_folder_path, file_read_path):
        parts = file_real_path.split(os.sep)
        return __joinpath(cache_folder_path, *parts[1:])

elif sys.platform == 'win32':
    def __get_cache_file_path(cache_folder_path, file_real_path):
        parts = file_real_path.split(os.sep)
        return __joinpath(cache_folder_path, parts[0][0].lower(), *parts[1:])

else:
    raise NotImplemented(
            'implement __get_cache_file_path() for your platform: {}'.format(
                sys.platform))


__language_specifications = {
    **dict.fromkeys(
        ['c', 'cpp', 'java', 'javascript'],
        dotdict(
            macro_prefix =          '//@',
            macro_suffix =          '',

            statement_prefix =      '//#',
            statement_suffix =      '',

            comment_prefix =        '//%',
            comment_suffix =        '',

            variable_prefix =       '${',
            variable_suffix =       '}',

            evaluation_prefix =     '$${{',
            evaluation_suffix =     '}}',
        ),
    ),

    **dict.fromkeys(
        ['perl', 'python'],
        dotdict(
            macro_prefix =          '#@',
            macro_suffix =          '',

            statement_prefix =      '##',
            statement_suffix =      '',

            comment_prefix =        '#%',
            comment_suffix =        '',

            variable_prefix =       '${',
            variable_suffix =       '}',

            evaluation_prefix =     '$${{',
            evaluation_suffix =     '}}',
        ),
    ),

    **dict.fromkeys(
        ['html'],
        dotdict(
            macro_prefix =          '<!--@',
            macro_suffix =          '-->',

            statement_prefix =      '<!--#',
            statement_suffix =      '-->',

            comment_prefix =        '<!--%',
            comment_suffix =        '-->',

            variable_prefix =       '${',
            variable_suffix =       '}',

            evaluation_prefix =     '$${{',
            evaluation_suffix =     '}}',
        ),
    )
}


def __apply_language(lang, compiler_env):
    for key, value in __language_specifications[lang]:
        setattr(compiler_env, key, value)

def __apply_settings(key, value, compiler_env):
    if key in ('mp', 'macro_prefix'):
        compiler_env.macro_prefix = value

    elif key in ('ms', 'macro_suffix'):
        compiler_env.macro_suffix = value

    elif key in ('sp', 'statement_prefix'):
        compiler_env.statement_prefix = value

    elif key in ('ss', 'statement_suffix'):
        compiler_env.statement_suffix = value

    elif key in ('vp', 'variable_prefix'):
        compiler_env.variable_prefix = value

    elif key in ('vs', 'variable_suffix'):
        compiler_env.variable_suffix = value

    elif key in ('ep', 'evaluation_prefix'):
        compiler_env.evaluation_prefix = value

    elif key in ('es', 'evaluation_suffix'):
        compiler_env.evaluation_suffix = value

    else:
        raise KeyError('unknown keyword: {!r}'.format(key))

def main(argv):
    options = __parse_argv(sys.argv)
    if isinstance(options, int):
        return options

    if __debug__:
        pprint(options)
        print_line()
        return 0

    # first clear cache folder
    if 'clear' in options.switchs:
        # clear cache
        pass

    # TODO: read _CONFIG_FILE_NAME as a `ini` or `json` and apply them to
    #       settings

    if 'arrange' in options.switchs:
        # we must process '-S' & FILEs according to their order.
        pass

    else:
        # initialize environments
        compiler_env = CompilerEnvironment()
        executor_env = ExecutorEnvironment()

        # apply settings & languages
        for item in options.settings_langs:
            if isinstance(item, tuple):
                # item is a (Key, Value)
                __apply_settings(item[0].lower(), item[1], compiler_env)
            else:
                # item is language specification
                __apply_language(lang, compiler_env)

        # compile and cache input files by threading

        # apply variable definitions, or undefinitions

        pass

if __name__ == '__main__':
    sys.exit(main(sys.argv))
