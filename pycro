#!/usr/bin/python3

import sys
import os

if sys.version_info[0] == 3:
    import builtins

elif sys.version_info[1] == 2:
    import __builtins__ as builtins

else:
    raise BaseException(
            "import builtins module for your python version: {}".format(
                ','.join(n for n in sys.version_info[:3]),
            )
        )

import io
import re
import collections
import marshal

if __debug__:
    from pprint import pprint

    def rprint(*objects, sep=', ', end='\n', file=sys.stdout):
        if objects:
            file.write(repr(objects[0]))
            for obj in objects[1:]:
                file.write(sep)
                file.write(repr(obj))
        file.write(end)

_CACHE_FOLDER_NAME = '.pycro_cache'

if sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    _HOME_DIRECTORY = os.environ['HOME']

elif sys.platform == 'win32':
    _HOME_DIRECTORY = os.environ['USERPROFILE']

else:
    raise NotImplemented(
            'implement _HOME_DIRECTORY for your platform: {}'.format(
                sys.platform))


# NOTE: '(?=(...))\1' works like atomic groups in other languages,
#       e.g: in perl: '(?>...)'.

# TODO: using re for matching for macros, statement, ... is slow, may be we
#       can do something like this:
#
#   line = line.strip(_SPACE_CHARS)
#   if line.startswith(prefix) and line.endswith(suffix):
#       ...
#
# WARNING: if we use the above mechanism, evey line that startswith(prefix) and
#          endswith(suffix) will treated as macros, statement, ...
#
# TODO: test speed of both ways.


_MACRO_PATTERN = r'\s*(?P<macro>{macros})\s*(?P<args>.*?)\s*'

# we comment statement pattern because
# _STATEMENT_PATTERN = r'(?P<stat>.*)'

_VARIABLE_NAME_PATTERN = r'[a-zA-Z_][a-zA-Z_0-9]+'

_VARIABLE_PATTERN = r'{prefix}(?P<name>{pattern}){suffix}'

_EVALUATION_PATTERN = r'{prefix}\s*(?P<eval>.*?)\s*{suffix}'



_DEFAULT_OUTFILE_VARIABLE_NAME = '__outfile__'

_DEFAULT_RUN_FUNCTION_NAME = '__run__'

_DEFAULT_INCLUDE_FUNCTION_NAME = '__include__'

_DEFAULT_PLACE_FUNCTION_NAME = '__place__'


_SPACE_CHARS = ' \t\n'


_CACHE_FILE_MAGIC_NUMBER = b'.pycroche'

_COMPILE_FLAGS = 0

_OPTIMIZE_FLAG = -1

_MARSHAL_VERSION = 4

_BIG_INTEGER_SIZE = 4

__USAGE = "usage: {} [OPTION]... [[--] FILE | -]..."
__HELP = """\
preprocess FILEs to standard output. if no FILE or if FILE is '-', standard
input is read.

Operation modes:
    -h, --help                      display this help and exit
    -a, --arrange-performance       perform options and FILEs according to
                                      their orders

Sortable options:
    -D, --define NAME[=VAR]         define NAME variable as having VALUE or
                                      {default_variable_value}
    -U, --undefine NAME             undefine NAME variable
    -S, --set KEY=VALUE             set KEY setting to VALUE
    -l, --load JSONFILE             load JSONFILE and update variables
    -I, --import MODULE             import MODULE to interpreter variables
    --                              read next argument as input FILE (don't
                                      treats '-' as standard input)
"""
__TRY = "try '{} --help' for more information."

# --- utilities ---

__joinpath = os.path.join
__abspath = os.path.abspath
__realpath = os.path.realpath

class dotdict(dict):
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

if sys.version_info >= (3, 4):
    __fullmatch = re._pattern_type.fullmatch

else:
    def __fullmatch(pattern, string):
        m = pattern.match(string)
        if m and m.end() == len(string):
            return m

# --- argument parser ---

def __print_help():
    print(__HELP.format(
        default_variable_value = _DEFAULT_VARIABLE_VALUE))

def __parse_argv(argv):
    result = dotdict(
            jobs = collections.deque(),
            operation_modes = set(),

            # NOTE: these fields will be filled on end
            inputs = None,
            settings = None,
            )

    next_args = collections.deque()

    for i, arg in enumerate(argv[1:]):

        # read next arg
        if next_args:
            next_arg = next_args.popleft()
            if next_arg[0] in ('define', 'undefine', 'input', 'setting',
                               'import'):
                result.jobs.append((next_arg[0], arg))

            else:
                raise BaseException("unknown argument name pushed to "
                        "next_args: {}".format(next_arg))

            continue

        # empty argument, ('')
        if not arg:
            print("error: empty argument: #{} argument".format(i + 1))
            print(__TRY.format(argv[0]))
            return 1

        if arg[0] == '-':

            # append stdin as input, ('-')
            if len(arg) == 1:
                continue

            if arg[1] == '-':

                # read next argument as input file name, ('--')
                if len(arg) == 2:
                    next_args.append(('input', '--'))
                    continue

                option = arg[2:]

                # show help, ('--help')
                if option == 'help':
                    print(__USAGE.format(argv[0]))
                    __print_help()
                    return 0

                # order performances, ('--order-performance')
                elif option == 'order-performance':
                    result.operation_modes.add('order')

                # define variable, ('--define')
                elif option == 'define':
                    next_args.append(('define', '--define'))

                # undefine variable, ('--undefine')
                elif option == 'undefine':
                    next_args.append(('undefine', '--undefine'))

                # change settings, ('--set')
                elif option == 'set':
                    next_args.append(('setting', '--set'))

                # load json files, ('--load')
                elif option == 'load':
                    next_args.append(('jsonfile', '--load'))

                # import module, ('--import')
                elif option == 'import':
                    next_args.append(('import', '--import'))

                else:
                    print("error: unknown option: '{}'".format(arg))
                    print(__TRY.format(argv[0]))
                    return 1

            else: # if arg[1] == '-'
                for ch in arg[1:]:

                    # show help, ('-h')
                    if ch == 'h':
                        print(__USAGE.format(sys.argv[0]))
                        __print_help()
                        return 0

                    # order performances, ('-o')
                    elif ch == 'o':
                        result.operation_modes.add('order')

                    # define variable, ('-D')
                    elif ch == 'D':
                        next_args.append(('define', '-D'))

                    # undefine variable, ('-U')
                    elif ch == 'U':
                        next_args.append(('undefine', '-U'))

                    # change settings, ('-S')
                    elif ch == 'S':
                        next_args.append(('setting', '-S'))

                    # load json files, ('-l')
                    elif ch == 'l':
                        next_args.append(('jsonfile', '-l'))

                    # import module, ('-i')
                    elif ch == 'i':
                        next_args.append(('import', '-I'))

                    else:
                        print("error: invalid option: '{}'".format('-' + ch))
                        print(__TRY.format(argv[0]))
                        return 1

        else: # if arg[0] == '-'
            result.jobs.append(('input', arg))

    if next_args:
        print("error: '{}' option requires an argument".format(
            next_args[0][1]
            ))
        print(__TRY.format(argv[0]))
        return 1

    result.inputs = \
            list(tup[1] for tup in result.jobs if tup[0] == 'input')

    result.settings = \
            list(tup[1] for tup in result.jobs if tup[0] == 'setting')

    result.jobs = list(result.jobs)
    return result

# *** binary file operations ***

# --- objects ---

def __write_object(outfile, _set):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_object(infile):
    return marshal.load(infile)

# --- code objects ---

def __write_code_object(outfile, code_object):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_code_object(infile):
    return marshal.load(infile)

# --- integers ---

def __write_int(outfile, integer, size = 1):
    outfile.write(integer.to_bytes(size, 'big', signed = True))

def __write_uint(outfile, integer, size = 1):
    outfile.write(integer.to_bytes(size, 'big', signed = False))

def __read_int(infile, size = 1):
    _buffer = infile.read(size)
    if len(_buffer) != size:
        raise EOFError(
                "End of file while reading {} byte integer".format(size))
    return int.from_bytes(_buffer, 'big', signed = True)

def __read_uint(infile, size = 1):
    _buffer = infile.read(size)
    if len(_buffer) != size:
        raise EOFError(
                "End of file while reading {} byte integer".format(size))
    return int.from_bytes(_buffer, 'big', signed = False)

# --- big integer ---

def __write_big_integer(outfile, size):
    outfile.write(size.to_bytes(__BIG_INTEGER_SIZE, 'big', signed = False))

def __read_big_integer(infile):
    _buffer = infile.read(__BIG_INTEGER_SIZE)
    if len(_buffer) != __BIG_INTEGER_SIZE:
        raise EOFError("End of file while reading size")
    return int.from_bytes(_buffer, 'big', signed = False)

# --- strings ---

def __write_string(outfile, string):
    _buffer = string.encode('utf-8')

    while len(_buffer) >= 0xFFFF:

        outfile.write(b'\xFF\xFF')
        outfile.write(_buffer[:0xFFFF])
        _buffer = _buffer[0xFFFF:]

    outfile.write(len(_buffer).to_bytes(2, 'big', signed = False))
    outfile.write(_buffer)

def __read_string(infile):
    _buffer = infile.read(2)
    if len(_buffer) != 2:
        raise EOFError("End of file while reading string")
    _buffer_size = int.from_bytes(_buffer, 'big', signed = False)

    _buffer = infile.read(_buffer_size)
    if len(_buffer) != _buffer_size:
        raise EOFError("End of file while reading string")
    _result = bytearray(_buffer)

    while _buffer_size == 0xFFFF:
        _buffer = infile.read(2)
        if len(_buffer) != 2:
            raise EOFError("End of file while reading string")
        _buffer_size = int.from_bytes(_buffer, 'big', signed = False)

        _buffer = infile.read(_buffer_size)
        if len(_buffer) != _buffer_size:
            raise EOFError("End of file while reading string")

        _result += _buffer

    return _result.decode('utf-8')

# *** errors ***

# NOTE: cross-python-version error values
_MACRO_REQUIRES = 1
_WITHOUT_PRECEDING = 2
_END_DOES_NOT_MATCH = 3
_UNTERMINATED_BLOCK = 4

class CompilerError(Exception):
    pass

# *** macros ***

# --- if macro ---

def _generate_if(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'if', 'a condition')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'if', args))
    env.indent += 1

    env.macro_stack.append('if')

# --- elif macro ---

def _generate_elif(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'elif', 'a condition')

    if env.macro_stack and env.macro_stack[-1] in ('if', 'elif'):

        env.indent -= 1
        outfile.write('{}{} {}\n'.format(env.tabs(), 'elif', args))
        env.indent += 1

        env.macro_stack[-1] = 'elif'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'elif', 'if/elif')

# --- for macro ---

def _generate_for(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'an iterable statement')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'for', args))
    env.indent += 1

    env.macro_stack.append('for')

# --- while macro ---

def _generate_while(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'while', 'a condition')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'while', args))
    env.indent += 1

    env.macro_stack.append('while')

# --- else macro ---

def _generate_else(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in \
            ('if', 'elif', 'for', 'while', 'except'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'else'))
        env.indent += 1

        env.macro_stack[-1] = 'else'

    else:
        raise CompilerError(_WITHOUT_PRECEDING,
                'else', 'if/elif/for/while/except')

# --- with macro ---

def _generate_with(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'with', 'an expression')

    outfile.write('{}{} {}\n'.format(env.tabs(), 'with', args))
    env.indent += 1

    env.macro_stack.append('with')

# --- try macro ---

def _generator_try(args, outfile, env):
    outfile.write('{}{}:\n'.format(env.tabs, 'try'))
    env.indent += 1

    env.macro_stack.append('try')

# -- except macro ---

def _generator_except(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'except', 'an expression')

    if env.macro_stack and env.macro_stack[-1] in ('try', 'except'):

        env.indent -= 1
        outfile.write('{}{} {}\n'.format(env.tabs(), 'except', args))
        env.indent += 1

        env.macro_stack[-1] = 'except'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'except', 'try/except')

# --- finally macro ---

def _generate_finally(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in ('try', 'except', 'else'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'finally'))
        env.indent += 1

        env.macro_stack[-1] = 'finally'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'finally', 'try/except/else')


# --- end macro ---

def _generate_end(args, outfile, env):
    if not env.macro_stack:
        raise CompilerError(_WITHOUT_PRECEDING, 'end', 'if/for/while/...')

    last_macro = env.macro_stack.pop()

    if args:
        if args != last_macro:
            raise CompilerError(_END_DOES_NOT_MATCH, 'end', last_macro, args)

    env.indent -= 1

# --- include macro ---

def _generate_include(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    outfile.write(
        '{}{}.({})'.format(
            env.tabs(),
            env.include_function_name,
            args
        )
    )
    # TODO: implement _generator_include

# --- place macro ---

def _place_function_creator(outfile, current_working_directory):
    def _place_function(file_name):
        with open(__joinpath(current_working_directory, file_name)) as infile:
            outfile.write(infile.read())

def _generate_place(args, outfile, env):
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'place', 'a filename')

    outfile.write(
        '{}{}.({})'.format(
            env.tabs(),
            env.place_function_name,
            args,
        )
    )

# --- exec macro ---

def _generate_exec(args, outfile, env):
    pass

def _exec_function_creator():
    def _exec_function(*args):
        subprocess.run(*args)

_default_code_generators = {
        'if': _generate_if,
        'elif': _generate_elif,
        'else': _generate_else,
        'for': _generate_for,
        'while': _generate_while,
        'with': _generate_with,
        'end': _generate_end,

        'place': _generate_place,
}

class CompilerEnvironment:
    def __init__(
            self,

            code_generators = None,

            macro_prefix = '%',
            macro_suffix = '',

            statement_prefix = '@',
            statement_suffix = '',

            comment_prefix = '#',
            comment_suffix = '',

            variable_prefix = '${',
            variable_suffix = '}',

            evaluation_prefix = '${{',
            evaluation_suffix = '}}',

            tab = '\t',
            indent = 0,

            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,
            run_function_name = _DEFAULT_RUN_FUNCTION_NAME,
            include_function_name = _DEFAULT_INCLUDE_FUNCTION_NAME,
            place_function_name = _DEFAULT_PLACE_FUNCTION_NAME,
            ):
        """intialize code generator environment"""

        self.code_generators = \
            code_generators or _default_code_generators.copy()

        self.macro_stack = collections.deque()


        # --- macro ---
        self.macro_prefix = macro_prefix
        self.macro_suffix = macro_suffix

        self.macro_re = re.compile(
            _MACRO_PATTERN.format(
                macros = '|'.join(macro for macro in self.code_generators),
            )
        )

        # --- statement ---
        self.statement_prefix = statement_prefix
        self.statement_suffix = statement_suffix

        # --- comment ---
        self.comment_prefix = comment_prefix
        self.comment_suffix = comment_suffix


        # --- evaluation & variable ---
        if (not variable_prefix) or (not variable_suffix):
            raise ValueError(
                    "variable_prefix & variable_suffix can't be empty")

        if (not evaluation_prefix) or (not evaluation_suffix):
            raise ValueError(
                    "evaluation_prefix & evaluation_suffix can't be empty")

        self.evaluation_variable_re = re.compile(
            _EVALUATION_PATTERN.format(
                prefix = re.escape(evaluation_prefix),
                suffix = re.escape(evaluation_suffix),
            ) + '|' +

            _VARIABLE_PATTERN.format(
                prefix = re.escape(variable_prefix),
                pattern = _VARIABLE_NAME_PATTERN,
                suffix = re.escape(variable_suffix),
            )
        )

        # --- variable names ---
        self.outfile_variable_name = outfile_variable_name
        self.run_function_name = run_function_name
        self.include_function_name = include_function_name
        self.place_function_name = place_function_name

        self.indent = indent
        self.tab = tab

    def tabs(self):
        return self.tab * self.indent

def generate_code(infile, outfile, env):
    """read from infile and generats python code to outfile"""

    code_generators = env.code_generators

    # --- macro ---
    macro_prefix = env.macro_prefix
    macro_suffix = env.macro_suffix

    macro_re = env.macro_re

    # --- statement ---
    statement_prefix = env.statement_prefix
    statement_suffix = env.statement_suffix

    # --- comment ---
    comment_prefix = env.comment_prefix
    comment_suffix = env.comment_suffix

    # --- evaluation variable ---
    evaluation_variable_re = env.evaluation_variable_re

    # --- outfile variable name ---
    outfile_variable_name = env.outfile_variable_name

    for line in infile:

        striped_line = line.strip(_SPACE_CHARS)

        # --- check macro ---
        if striped_line.startswith(macro_prefix) and \
                striped_line.endswith(macro_suffix):

            macro_striped_line = \
                striped_line[   len(macro_prefix): \
                                len(striped_line) - len(macro_suffix)]

            m = __fullmatch(macro_re, macro_striped_line)
            if m:

                generate_code = code_generators[m.group('macro')]
                generate_code(m.group('args'), outfile, env)

                continue

        # --- check statement ---
        if striped_line.startswith(statement_prefix) and \
                striped_line.endswith(statement_suffix):
            outfile.write(
                '{}{}\n'.format(
                    env.tabs(),
                    striped_line[
                            len(statement_prefix): \
                            len(striped_line) -len(statement_suffix)]\
                                .strip(_SPACE_CHARS),
                    )
                )

            continue

        # --- check comment ---
        if striped_line.startswith(comment_prefix) and \
                striped_line.endswith(comment_suffix):
            outfile.write('\n')

            continue

        # --- check for evaluations ---
        outfile.write(env.tabs())

        m = evaluation_variable_re.search(line)
        while m:

            # --- write primitive remains ---
            if m.start() != 0:
                outfile.write(
                    '{}.write({});'.format(
                        outfile_variable_name,
                        repr(line[:m.start()]),
                    )
                )

            name = m.group('name')
            if name is None:
                # --- write evaluation ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        m.group('eval'),
                    )
                )

            else:
                # --- write variable ---
                outfile.write(
                    '{}.write(str({}));'.format(
                        outfile_variable_name,
                        name,
                    )
                )

            # --- check remaining line ---
            if m.end() == len(line):
                outfile.write('\n')
                break

            line = line[m.end():]
            m = evaluation_variable_re.search(line)

        else:

            # --- writing text ---
            outfile.write(
                '{}.write({});\n'.format(
                    outfile_variable_name,
                    repr(line),
                )
            )

    if env.macro_stack:
        raise CompilerError(_UNTERMINATED_BLOCK, env.macro_stack[-1])

def compile_code(infile, env,
        compile_flags = _COMPILE_FLAGS, optimize = _OPTIMIZE_FLAG):

    string_buffer = io.StringIO()
    with string_buffer:
        generate_code(infile, string_buffer, env)

    return compile(string_buffer.getvalue(), infile.name, 'exec',
            flags, True, optimize)

_default_builtins = builtins

class ExecutorError:
    def __init__(self,
            variables = None,
            builtins = None,

            current_working_directory = '.',

            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,
            run_function_name = _DEFAULT_RUN_FUNCTION_NAME,
            include_function_name = _DEFAULT_INCLUDE_FUNCTION_NAME,
            place_function_name = _DEFAULT_PLACE_FUNCTION_NAME,
            ):

        if variables is None:
            variables = {}

        if '__builtins__' not in variables:
            if builtins is None:
                builtins = _default_builtins.copy()

            variables['__builtins__'] = builtins

        self.current_working_directory = current_working_directory

        self.outfile_variable_name = outfile_variable_name
        self.run_function_name = run_function_name
        self.include_function_name = include_function_name
        self.place_function_name = place_function_name

def execute_code_object(code_object, outfile, env):
    variables[env.outfile_variable_name] = outfile
    variables[env.run_function_name] = _place_function_creator()

    return exec(code_object, variables)


# --- main functions ---

def write_compiled_code(code_object, env, outfile):
    # --- writing to file ---
    outfile.write(_CACHE_FILE_MAGIC_NUMBER)

    __write_big_integer(outfile, len(env.code_generators))
    for name in env.code_generators:
        __write_string(outfile, name)

    __write_string(outfile, env.macro_prefix)
    __write_string(outfile, env.macro_suffix)

    __write_string(outfile, env.statement_prefix)
    __write_string(outfile, env.statement_suffix)

    __write_string(outfile, env.comment_prefix)
    __write_string(outfile, env.comment_suffix)

    __write_string(outfile, env.evaluation_prefix)
    __write_string(outfile, env.evaluation_suffix)

    __write_code_object(outfile, code_object)


# --- main function ---

_default_language_specifications = {
    'c': dotdict(
        macro_prefix =          '//%',
        macro_suffix =          '',

        statement_prefix =      '//@',
        statement_suffix =      '',

        comment_prefix =        '//#',
        comment_suffix =        '',

        variable_prefix =       '${',
        variable_suffix =       '}',

        evaluation_prefix =     '$${{',
        evaluation_suffix =     '}}',
    )
}

if sys.platform == 'win32':
    def __get_cache_file_path(cache_folder_path, file_real_path):
        parts = file_real_path.split(os.sep)
        return __joinpath(cache_folder_path, parts[0][0].lower(), *parts[1:])

else:
    raise NotImplemented(
            'implement __get_cache_file_path() for your platform: {}'.format(
                sys.platform))

def main(argv):
    options = __parse_argv(sys.argv)
    if isinstance(options, int):
        return options

    for file_name in options.inputs:
        pass

if __name__ == '__main__':
    if __debug__:
        string_buffer = io.StringIO()
        env = CompilerEnvironment(**_default_language_specifications['c'])
        with open('temp.c') as infile:
            generate_code(infile, string_buffer, env)

        print(string_buffer.getvalue())
        print('-' * 80)

    else:
        sys.exit(main(sys.argv))
