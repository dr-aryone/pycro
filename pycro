#!/usr/bin/python3

import sys
import os
import io
import re
import collections
import marshal


_CACHE_FOLDER_NAME = '.pycro_cache'

if sys.platform.startswith('linux') or sys.platform.startswith('freebsd'):
    _HOME_DIRECTORY = os.environ['HOME']

elif sys.platform == 'win32':
    _HOME_DIRECTORY = os.environ['USERPROFILE']

else:
    raise NotImplemented(
            'implement _HOME_DIRECTORY for your platform: {}'.format(
                sys.platform))


# NOTE: '(?=(...))\1' works like atomic groups in other languages,
#       e.g: in perl: '(?>...)'.

# TODO: using re for matching for macros, statement, ... is slow, may be we
#       can do something like this:
#
#   line = line.strip(_SPACE_CHARS)
#   if line.startswith(prefix) and line.endswith(suffix):
#       ...
#
# WARNING: if we use the above mechanism, evey line that startswith(prefix) and
#          endswith(suffix) will treated as macros, statement, ...
#
# TODO: test speed of both ways.


_MACRO_PATTERN = r'\s*{prefix}(?P<macro>{macros})\s(?P<args>.*){suffix}\s*'

_STATEMENT_PATTERN = r'\s*{prefix}(?P<stat>.*){suffix}\s*'

_EVALUATION_PATTERN = r'{prefix}(?P<eval>.*){suffix}'

_COMMENT_PATTERN = r'\s*{prefix}.*{suffix}\s*'

_NEXT_LINE_RE = r'\s*{prefix}'


_DEFAULT_OUTFILE_VARIABLE_NAME = '__outfile__'

_SPACE_CHARS = ' \t\n'


_CACHE_FILE_MAGIC_NUMBER = b'.pycroche'

_COMPILE_FLAGS = 0

_MARSHAL_VERSION = 4

__LanguageSpecification = collections.namedtuple('__LanguageSpecification',
    [
        'macro_prefix',
        'macro_suffix',

        'statement_prefix',
        'statement_suffix',

        'evaluation_prefix',
        'evaluation_suffix',

        'comment_prefix',
        'comment_suffix',

    ]
)

_default_language_specifications = {
    'c': __LanguageSpecification(
            '//#', '',

            '//-', '',

            '/*[', ']*/',

            '//#', '',
    )
}

__USAGE = "usage: {} [OPTION]... [[--] FILE | -]..."
__HELP = """\
preprocess FILEs to standard output. if no FILE or if FILE is '-', standard
input is read.

Operation modes:
    -h, --help                      display this help and exit
    -a, --arrange-performance       perform options and FILEs according to
                                      their orders

Sortable options:
    -D, --define NAME[=VAR]         define NAME variable as having VALUE or
                                      {default_variable_value}
    -U, --undefine NAME             undefine NAME variable
    -S, --set KEY=VALUE             set KEY setting to VALUE
    -l, --load JSONFILE             load JSONFILE and update variables
    -I, --import MODULE             import MODULE to interpreter variables
    --                              read next argument as input FILE (don't
                                      treats '-' as standard input)
"""
__TRY = "try '{} --help' for more information."

# --- utilities ---

class dotdict(dict):
    __getattr__ = dict.get
    __setattr__ = dict.__setitem__
    __delattr__ = dict.__delitem__

# --- argument parser ---

def __print_help():
    print(__HELP.format(
        default_variable_value = _DEFAULT_VARIABLE_VALUE))

def __parse_argv(argv):
    result = dotdict(
            jobs = collections.deque(),
            operation_modes = set(),

            # NOTE: these fields will be filled on end
            inputs = None,
            settings = None,
            )

    next_args = collections.deque()

    for i, arg in enumerate(argv[1:]):

        # read next arg
        if next_args:
            next_arg = next_args.popleft()
            if next_arg[0] in ('define', 'undefine', 'input', 'setting',
                               'import'):
                result.jobs.append((next_arg[0], arg))

            else:
                raise BaseException("unknown argument name pushed to "
                        "next_args: {}".format(next_arg))

            continue

        # empty argument, ('')
        if not arg:
            print("error: empty argument: #{} argument".format(i + 1))
            print(__TRY.format(argv[0]))
            return 1

        if arg[0] == '-':

            # append stdin as input, ('-')
            if len(arg) == 1:
                continue

            if arg[1] == '-':

                # read next argument as input file name, ('--')
                if len(arg) == 2:
                    next_args.append(('input', '--'))
                    continue

                option = arg[2:]

                # show help, ('--help')
                if option == 'help':
                    print(__USAGE.format(argv[0]))
                    __print_help()
                    return 0

                # order performances, ('--order-performance')
                elif option == 'order-performance':
                    result.operation_modes.add('order')

                # define variable, ('--define')
                elif option == 'define':
                    next_args.append(('define', '--define'))

                # undefine variable, ('--undefine')
                elif option == 'undefine':
                    next_args.append(('undefine', '--undefine'))

                # change settings, ('--set')
                elif option == 'set':
                    next_args.append(('setting', '--set'))

                # load json files, ('--load')
                elif option == 'load':
                    next_args.append(('jsonfile', '--load'))

                # import module, ('--import')
                elif option == 'import':
                    next_args.append(('import', '--import'))

                else:
                    print("error: unknown option: '{}'".format(arg))
                    print(__TRY.format(argv[0]))
                    return 1

            else: # if arg[1] == '-'
                for ch in arg[1:]:

                    # show help, ('-h')
                    if ch == 'h':
                        print(__USAGE.format(sys.argv[0]))
                        __print_help()
                        return 0

                    # order performances, ('-o')
                    elif ch == 'o':
                        result.operation_modes.add('order')

                    # define variable, ('-D')
                    elif ch == 'D':
                        next_args.append(('define', '-D'))

                    # undefine variable, ('-U')
                    elif ch == 'U':
                        next_args.append(('undefine', '-U'))

                    # change settings, ('-S')
                    elif ch == 'S':
                        next_args.append(('setting', '-S'))

                    # load json files, ('-l')
                    elif ch == 'l':
                        next_args.append(('jsonfile', '-l'))

                    # import module, ('-i')
                    elif ch == 'i':
                        next_args.append(('import', '-I'))

                    else:
                        print("error: invalid option: '{}'".format('-' + ch))
                        print(__TRY.format(argv[0]))
                        return 1

        else: # if arg[0] == '-'
            result.jobs.append(('input', arg))

    if next_args:
        print("error: '{}' option requires an argument".format(
            next_args[0][1]
            ))
        print(__TRY.format(argv[0]))
        return 1

    result.inputs = \
            list(tup[1] for tup in result.jobs if tup[0] == 'input')

    result.settings = \
            list(tup[1] for tup in result.jobs if tup[0] == 'setting')

    result.jobs = list(result.jobs)
    return result

# --- binary file operations ---

def __write_code_object(outfile, code_object):
    marshal.dump(outfile, code_object, _MARSHAL_VERSION)

def __read_code_object(infile):
    return marshal.load(infile)

def __write_string(outfile, string):
    _buffer = string.encode('utf-8')

    while len(_buffer) >= 0xFFFF:

        outfile.write(b'\xFF\xFF')
        outfile.write(_buffer[:0xFFFF])
        _buffer = _buffer[0xFFFF:]

    outfile.write(len(_buffer).to_bytes(2, 'big', signed=False))
    outfile.write(_buffer)

def __read_string(infile):
    _buffer_size = int.from_bytes(infile.read(2), 'big', signed=False)
    _buffer = bytearray(infile.read(_buffer_size))

    while _buffer_size == 0xFFFF:
        _buffer_size = int.from_bytes(infile.read(2), 'big', signed=False)
        _buffer += infile.read(_buffer_size)

    return _buffer.decode('utf-8')

# --- errors ---
_MACRO_REQUIRES = 1
_WITHOUT_PRECEDING = 2
_DOES_NOT_MATCH = 3
_UNTERMINATED_BLOCK = 4

class CompilerError(Exception):
    pass

# --- if macro ---

def _generate_if(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'if', 'a condition')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'if', args))
    env.indent += 1

    env.macro_stack.append('if')

# --- elif macro ---

def _generate_elif(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'elif', 'a condition')

    if env.macro_stack and env.macro_stack[-1] in ('if', 'elif'):

        env.indent -= 1
        outfile.write('{}{} {}:\n'.format(env.tabs(), 'elif', args))
        env.indent += 1

        env.macro_stack[-1] = 'elif'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'elif', 'if/elif')

# --- for macro ---

def _generate_for(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'an iterable statement')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'for', args))
    env.indent += 1

    env.macro_stack.append('for')

# --- while macro ---

def _generate_while(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'while', 'a condition')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'while', args))
    env.indent += 1

    env.macro_stack.append('while')

# --- else macro ---

def _generate_else(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in ('if', 'elif', 'for',
            'while', 'except'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'else'))
        env.indent += 1

        env.macro_stack[-1] = 'else'

    else:
        raise CompilerError(_WITHOUT_PRECEDING,
                'else', 'if/elif/for/while/except')

# --- with macro ---

def _generate_with(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'with', 'an expression')

    outfile.write('{}{} {}:\n'.format(env.tabs(), 'with', args))
    env.indent += 1

    env.macro_stack.append('with')

# --- try macro ---

def _generator_try(args, outfile, env):
    outfile.write('{}{}:\n'.format(env.tabs, 'try'))
    env.indent += 1

    env.macro_stack.append('try')

# -- except macro ---

def _generator_except(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'except', 'an expression')

    if env.macro_stack and env.macro_stack[-1] in ('try', 'except'):

        env.indent -= 1
        outfile.write('{}{} {}:\n'.format(env.tabs(), 'except', args))
        env.indent += 1

        env.macro_stack[-1] = 'except'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'except', 'try/except')

# --- finally macro ---

def _generate_finally(args, outfile, env):
    if env.macro_stack and env.macro_stack[-1] in ('try', 'except', 'else'):

        env.indent -= 1
        outfile.write('{}{}:\n'.format(env.tabs(), 'finally'))
        env.indent += 1

        env.macro_stack[-1] = 'finally'

    else:
        raise CompilerError(_WITHOUT_PRECEDING, 'finally', 'try/except/else')


# --- end macro ---

def _generate_include(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    # TODO: implement _generator_include

def _generate_place(args, outfile, env):
    args = args.strip(_SPACE_CHARS)
    if not args:
        raise CompilerError(_MACRO_REQUIRES, 'for', 'a filename')

    # TODO: complete _generator_place()


def _generate_end(args, outfile, env):
    if not env.macro_stack:
        raise CompilerError(_WITHOUT_PRECEDING, 'end', 'if/for/while/...')

    last_macro = env.macro_stack.pop()

    args = args.strip(_SPACE_CHARS)
    if args:
        if args != last_macro:
            raise CompilerError(_DOES_NOT_MATCH, 'end', last_macro, args)

    env.indent -= 1


_default_code_generators = {
        'if': _generate_if,
        'elif': _generate_elif,
        'else': _generate_else,
        'for': _generate_for,
        'while': _generate_while,
        'with': _generate_with,
        'end': _generate_end,
}

def _generate_line(line, outfile, env):
    outfile.write(env.tabs())

    m = env.evaluation_re.search(line)
    while m:

        # --- write primitive remains ---
        if m.start() != 0:
            outfile.write(
                '{}.write({});'.format(
                    env.outfile_variable_name,
                    repr(line[:m.start()]),
                )
            )

        # --- write evaluation ---
        outfile.write(
             '{}.write(str({}));'.format(
                 env.outfile_variable_name,
                 m.group('eval'),
             )
        )

        # --- check remaining line ---
        if m.end() == len(line):
            outfile.write('\n')
            break

        line = line[m.end():]
        m = env.evaluation_re.search(line)

    else:

        # --- writing text ---
        outfile.write(
            '{}.write({});\n'.format(
                env.outfile_variable_name,
                repr(line),
            )
        )

class CompilerEnvironment:
    def __init__(
            self,

            code_generators = None,

            macro_prefix = '%',
            macro_suffix = '',

            statement_prefix = '#',
            statement_suffix = '',

            # TODO: may be we must add a variable subsitution mechanism.

            evaluation_prefix = '${',
            evaluation_suffix = '}',

            comment_prefix = '#',
            comment_suffix = '',

            line_continuation = '//\n',
            next_line_prefix = '//',

            tab = '\t',
            indent = 0,

            outfile_variable_name = _DEFAULT_OUTFILE_VARIABLE_NAME,
            ):
        """intialize code generator environment"""

        self.code_generators = \
            code_generators or _default_code_generators.copy()

        self.macro_stack = collections.deque()

        self.macro_re = re.compile(
            _MACRO_PATTERN.format(
                prefix = \
                    (re.escape(macro_prefix) + '\s*') if macro_prefix else '',
                macros = '|'.join(macro for macro in self.code_generators),
                suffix = re.escape(macro_suffix),
            )
        )

        self.statement_re = re.compile(
            _STATEMENT_PATTERN.format(
                prefix = re.escape(statement_prefix),
                suffix = re.escape(statement_suffix),
            )
        )

        self.evaluation_re = re.compile(
            _EVALUATION_PATTERN.format(
                prefix = re.escape(evaluation_prefix),
                suffix = re.escape(evaluation_suffix),
            )
        )

        self.comment_re = re.compile(
            _COMMENT_PATTERN.format(
                prefix = re.escape(comment_prefix),
                suffix = re.escape(comment_suffix),
            )
        )

        self.line_continuation = line_continuation
        self.next_line_re = re.compile(
            _NEXT_LINE_RE.format(
                prefix = re.escape(next_line_prefix),
            )
        )

        self.indent = indent
        self.tab = tab

        self.outfile_variable_name = outfile_variable_name

    def tabs(self):
        return self.tab * self.indent

def generate_code(infile, outfile, env):
    """read from infile and generats python code to outfile"""

    macro_re = env.macro_re
    statement_re = env.statement_re
    comment_re = env.comment_re

    line_continuation = env.line_continuation
    next_line_re = env.next_line_re

    for line in infile:

        if line_continuation:
            while line.endswith(line_continuation):
                line = line[:-len(line_continuation)]

                next_line = infile.readline()
                if not next_line:
                    break

                outfile.write('\n')

                m = next_line_re.match(next_line)
                if m:
                    next_line = next_line[m.end():]

                line += next_line

        m = macro_re.fullmatch(line)
        if m:
            code_generator = env.code_generators[m.group('macro')]
            code_generator(m.group('args'), outfile, env)

            continue

        m = statement_re.fullmatch(line)
        if m:
            outfile.write(
                '{}{}\n'.format(
                    env.tabs(),
                    m.group('stat').strip(_SPACE_CHARS),
                    )
                )

            continue

        if comment_re.fullmatch(line):
            outfile.write('\n')

            continue

        _generate_line(line, outfile, env)

    if env.macro_stack:
        raise GenerateError(_UNTERMINATED_BLOCK, env.macro_stack[-1])

def compile_code(infile, outfile, env,
        compile_flags = _COMPILE_FLAGS, optimize = -1):
    string_buffer = io.StringIO()
    with string_buffer:
        generate_code(infile, string_buffer, env)

    code_object = compile(string_buffer.getvalue(), infile.name, 'exec',
            flags, True, optimize)

    # --- magic number ---
    outfile.write(_CACHE_FILE_MAGIC_NUMBER)

    # TODO: it must write prefixes & suffixes

    outfile.write()

    __write_code_object(outfile, code_object)

def _compile_if_needed():
    pass

def execute_code(infile, outfile, variables, env):
    if infile.read(len(_CACHE_FILE_MAGIC_NUMBER)) != _CACHE_FILE_MAGIC_NUMBER:
        raise ValueError('file magic number mismatch!')

    code_object = __read_code_object(infile)

    exec(code_object, variables)


# --- main function ---

__joinpath = os.path.join

if sys.platform == 'win32':
    def __get_cache_file_path(cache_folder_path, file_real_path):
        parts = file_real_path.split(os.sep)
        return __joinpath(cache_folder_path, parts[0][0].lower(), *parts[1:])

else:
    raise NotImplemented(
            'implement __get_cache_file_path() for your platform: {}'.format(
                sys.platform))

def main(argv):
    options = __parse_argv(sys.argv)
    if isinstance(options, int):
        return options

    for file_name in options.inputs:
        pass

if __name__ == '__main__':
    if __debug__:
        string_buffer = io.StringIO()
        env = CompilerEnvironment(
            macro_prefix = '//#',
            statement_prefix = '//@',
        )
        with open('temp.c') as infile:
            generate_code(infile, string_buffer, env)

        print(string_buffer.getvalue())
        print('-' * 80)

        exec(string_buffer.getvalue(),
                {'__outfile__': sys.stdout})

    else:
        sys.exit(main(sys.argv))
